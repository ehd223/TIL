객체지향(OOP) II
=========

> 과정 10일차 (19.05.24)

### 1. 재귀함수(재귀 메서드)
- 사용하는 이유 : 재귀호출이 주는 논리적 간결함.
  - 효율적이라도 알아보기 힘들게 작성하는 것 보다 다소 비효율적이더라도 알아보기 쉽게 작성하는 것이 논리적 오류가 발생할 확률도 줄어들고 수정하기도 좋다.
  - 재귀호출의 간결함이 주는 이득이 충분히 큰 경우에만 사용해야 한다.

> static 메소드 : Math 클래스 처럼 인스턴스가 필요 없이 기능적인 역할만 하는 메소드를 만들 때 사용할 수 있다.
  
### 2. 오버로딩
- 클래스 내에서 같은 이름으로 다른 기능을 하는 메서드를 만들 수 있다.(오버로딩)
- 단 인자의 갯수, 타입, 리턴형 등이 달라야 생성 가능

### 3. 생성자
- 직접 만든 생성자가 하나도 없으면 자동으로 생성(default 생성자 / 컴파일 시.)
- 직접 만든 생성자가 하나라도 있으면 default 생성자를 자동으로 생성 X
- 생성자를 통해 인스턴스를 복사할 수도 있다(깊은 복사)
```java
Car(Car c){
  this.color = c.color;
  this.geartype = c.geartype;
  ...
}
```

### 4. 멤버 변수의 초기화
- 세 가지 방법
  1. 명시적 초기화(explicit initialization)
      - 간단하고 명료
      ```java
        class Car{
          int door = 4;
          Engine e = new Engine();
          ...
        }
      ```
  2. 생성자(constructor)
  3. 초기화 블럭(initialization block)
      - 보다 복잡한 초기화에 사용. (for, if 등의 구문 사용 가능.)
      - 클래스 초기화 블럭
        - 클래스가 처음 로드 될 때 한 번만 수행
      - 인스턴스 초기화 블럭
        - 생성자와 같이 인스턴스를 생성할 때 마다 수행
        - 생성자와 함께 사용할 경우 공통으로 수행되어야 하는 복잡한 구문을 초기화 블럭에 작성함으로써 코드의 중복을 줄이고, 코드가 간결해질 수 있다.
      ```java
      class Car{
        // 클래스 초기화 블럭
        static{ 
          count = 1000; // count 는 static 으로 선언된 클래스의 변수
                        // 클래스가 로드될 때 한 번만 실행됨.
        }
        // 인스턴스 초기화 블럭
        { 
          // 모든 차의 인스턴스마다 필요한 serialNo를 증가시키는 블럭을
          // 생성자에서 분리함으로써 생성자의 코드가 간결해짐 
          count++;
          serialNo = count;
        }
        //생성자
        Car(){
          color = "white";
          gearType = "Auto";
        }
        Car(String color, String gearType){
          this.color = color;
          this.gearType = gearType;
        }
      }
      ```
